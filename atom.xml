<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术浩</title>
  
  <subtitle>专注于WEB前端开发</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jshao.org.cn/"/>
  <updated>2019-01-30T01:13:19.195Z</updated>
  <id>http://jshao.org.cn/</id>
  
  <author>
    <name>张浩</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS中 UNDEFINED重写 与 VOID 0</title>
    <link href="http://jshao.org.cn/2019/01/30/javascript03/"/>
    <id>http://jshao.org.cn/2019/01/30/javascript03/</id>
    <published>2019-01-30T01:07:48.000Z</published>
    <updated>2019-01-30T01:13:19.195Z</updated>
    
    <content type="html"><![CDATA[<p>在看一些开源源码的时候经常会看到这样一个判断句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a !== viod <span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>目的是判断指定的变量是不是一个undefined。<br>这么写，是因为，在ES5之前，undefined是可以被重写的，在ES5之后修复了这个问题，但只是全局作用域下不可以了，在局部作用域依然可以改写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="literal">undefined</span>);<span class="comment">//1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>); <span class="comment">//number</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在看一些开源源码的时候经常会看到这样一个判断句：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://jshao.org.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="undefined" scheme="http://jshao.org.cn/tags/undefined/"/>
    
      <category term="void" scheme="http://jshao.org.cn/tags/void/"/>
    
  </entry>
  
  <entry>
    <title>函数声明和函数表达式的区别</title>
    <link href="http://jshao.org.cn/2019/01/29/javascript02/"/>
    <id>http://jshao.org.cn/2019/01/29/javascript02/</id>
    <published>2019-01-29T08:49:07.000Z</published>
    <updated>2019-01-29T08:56:01.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、函数声明"><a href="#一、函数声明" class="headerlink" title="一、函数声明"></a>一、函数声明</h1><p>函数声明是以function关键字开头，接着是必须的函数（变量）名和以逗号分隔的可选的参数列表，再接着就是以大括号封装的函数体。函数声明必须是一个独立的Javascript语句。</p><h1 id="二、函数表达式"><a href="#二、函数表达式" class="headerlink" title="二、函数表达式"></a>二、函数表达式</h1><p>在任何情况下都是其它Javascript语句的一部分（比如赋值表达式等号的右侧、函数的参数）的函数被称为函数表达式。</p><h1 id="三、比较"><a href="#三、比较" class="headerlink" title="三、比较"></a>三、比较</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunctionDeclaration</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下为函数表达式</span></span><br><span class="line"><span class="keyword">var</span> myFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">myFunc(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">namedFunctionExpression</span> (<span class="params"></span>) </span>&#123; &#125;)();</span><br><span class="line"></span><br><span class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</span><br><span class="line">-<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</span><br><span class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、函数声明&quot;&gt;&lt;a href=&quot;#一、函数声明&quot; class=&quot;headerlink&quot; title=&quot;一、函数声明&quot;&gt;&lt;/a&gt;一、函数声明&lt;/h1&gt;&lt;p&gt;函数声明是以function关键字开头，接着是必须的函数（变量）名和以逗号分隔的可选的参数列表，再接着就是以
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://jshao.org.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="函数声明" scheme="http://jshao.org.cn/tags/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E/"/>
    
      <category term="函数表达式" scheme="http://jshao.org.cn/tags/%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="匿名函数" scheme="http://jshao.org.cn/tags/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    
      <category term="立即执行函数" scheme="http://jshao.org.cn/tags/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript原型对象</title>
    <link href="http://jshao.org.cn/2019/01/25/javascript01/"/>
    <id>http://jshao.org.cn/2019/01/25/javascript01/</id>
    <published>2019-01-24T16:36:59.000Z</published>
    <updated>2019-01-29T08:51:02.977Z</updated>
    
    <content type="html"><![CDATA[<!-- <img src="/images/prototype&__proto__.png" style="width:100%;" /> --><!-- ![prototype&__proto__](/images/prototype&__proto__.png "prototype&__proto__") --><!-- [Javascript](http://zhuzhuyule.xyz) --><h1 id="一、什么是原型"><a href="#一、什么是原型" class="headerlink" title="一、什么是原型"></a>一、什么是原型</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原型是Javascript中的继承的基础，JavaScript的继承就是基于原型的继承。</span><br></pre></td></tr></table></figure><h2 id="1-1-函数的原型对象"><a href="#1-1-函数的原型对象" class="headerlink" title="1.1 函数的原型对象"></a>1.1 函数的原型对象</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在Javascript中，我们创建一个函数A（就是声明一个函数），那么浏览器就会在内存中创建一个对象（假设为B对象），而且每个函数都默认会有一个属性prototype指向了这个对象（即：prototype的属性的值是这个对象B）。这个对象B就是函数A的原型对象，简称函数的原型。这个原型对象B默认会有一个属性constructor指向了这个函数A（ 意思就是说：constructor属性的值是函数A）。</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">声明一个函数，则这个函数默认会有一个属性叫prototype。而且浏览器会自动按照一定的规则创建一个对象，这个对象就是函数的原型对象，prototype属性指向这个原型对象。这个原型对象有一个属性叫constructor执行了这个函数</span><br><span class="line"></span><br><span class="line">注意：原型对象默认只有属性：constructor。其他都是从Object继承而来，暂且不用考虑。</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-使用构造函数创建对象"><a href="#1-2-使用构造函数创建对象" class="headerlink" title="1.2 使用构造函数创建对象"></a>1.2 使用构造函数创建对象</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">当把一个函数作为构造函数（理论上任何函数都可以作为构造函数）使用new创建对象的时候，那么这个对象就会存在一个默认的不可见的属性，来指向构造函数的原型对象。这个不可见的属性我们一般用[[prototype]]来表示，只是这个属性没有办法直接访问到。</span><br><span class="line"></span><br><span class="line">看下面的代码：</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">利用构造函数创建一个对象，则这个对象会自动添加一个不可见的属性[[prototype]]，而且这个属性指向了构造函数的原型对象</span><br><span class="line">*/</span><br><span class="line">var p1 = new Person();</span><br><span class="line"></span><br><span class="line">先看如下说明：</span><br><span class="line"></span><br><span class="line">1.创建p1对象虽然使用的是Person构造函数，但是对象创建出来之后，这个p1对象其实已经与Person构造函数没有任何关系了，p1对象的[[prototype]]属性指向的是Person构造函数的原型对象。</span><br><span class="line"></span><br><span class="line">2.如果使用new Person()创建多个对象，则对个对象都会同时指向Person构造函数的原型对象。</span><br><span class="line"></span><br><span class="line">3.我们可以手动给这个原型对象添加属性和方法，那么p1、p2、p3...这些对象就会共享这些在原型对象中添加的属性和方法。</span><br><span class="line"></span><br><span class="line">4.如果我们访问p1中的一个属性name，如果在p1对象中找到，则直接返回。如果在p1对象中没有找到，则直接去p1对象的[[prototype]]属性指向的原型对象中查找，如果查找到则返回。（ 如果原型中也没有找到，则继续向上找原型的原型--原型链。后面再讲）。</span><br><span class="line"></span><br><span class="line">5.如果通过p1对象添加了一个属性name，则对p1对象来说就屏蔽了原型对象中的属性name。换句话说：在p1中就没有办法访问到原型对象的属性name了。</span><br><span class="line"></span><br><span class="line">6.通过p1对象只能读取原型对象中的属性name的值，而不能修改原型对象中的属性name的值。p1.name = <span class="string">"李四"</span>；并不是修改了原型对象中的name的值，而是在p1对象中添加了一个属性name。</span><br><span class="line"></span><br><span class="line">再看下面的代码：</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//可以使用Person.prototype直接访问到原型对象</span><br><span class="line">//给Person函数的原型对象中添加一个属性name并且值是“张三”</span><br><span class="line">Person.prototype.name = <span class="string">"张三"</span>;</span><br><span class="line">Person.prototype.age = 20;</span><br><span class="line"></span><br><span class="line">var p1 = new Person();</span><br><span class="line">/*</span><br><span class="line">访问p1对象的属性name，虽然在p1对象中我们并没有明确的添加属性name，但是p1的[[prototype]]属性指向的原型对象中有name属性，所以这个地方可以访问到属性的值。注意：这个时候不能通过p1对象删除name属性，因为只能删除在p1中添加的对象。</span><br><span class="line">*/</span><br><span class="line">alert(p1.name);//张三</span><br><span class="line"></span><br><span class="line">var p2 = new Person();</span><br><span class="line">alert(p2.name);//张三 都是从原型对象中找到的，所以一样。</span><br><span class="line"></span><br><span class="line">alert(p1.name === p2.name);//<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">//由于不能通过p1对象修改原型对象中的属性值，所以这种方法就直接在p1中添加了一个新的属性name，然后在p1中就无法访问到原型对象中的属性name值。</span><br><span class="line">p1.name = <span class="string">"李四"</span>;</span><br><span class="line">alert(p1.name);//李四</span><br><span class="line">//由于p2中没有name属性，则对p2来说仍然是访问的原型对象中的属性name</span><br><span class="line">alert(p2.name);//张三</span><br></pre></td></tr></table></figure><h1 id="二、与原型有关的几个属性和方法"><a href="#二、与原型有关的几个属性和方法" class="headerlink" title="二、与原型有关的几个属性和方法"></a>二、与原型有关的几个属性和方法</h1><h2 id="2-1-prototype属性"><a href="#2-1-prototype属性" class="headerlink" title="2.1 prototype属性"></a>2.1 prototype属性</h2><p>prototype存在于构造函数中（其实任意函数中都有，只是不是构造函数的时候prototype我们不关注而已），它指向了这个构造函数的原型对象。</p><h2 id="2-2-constructor属性"><a href="#2-2-constructor属性" class="headerlink" title="2.2 constructor属性"></a>2.2 constructor属性</h2><p>constructor属性存在于原型对象中，它指向了构造函数。</p><p>看下面的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">alert(Person.prototype.constructor === Person);//<span class="literal">true</span></span><br><span class="line">var p1 = new Person();</span><br><span class="line">//使用instanceof操作符可以判断一个对象的类型。</span><br><span class="line">//typeof一般用来获取简单类型和函数。而引用类型一般使用instanceof，因为引用类型用typeof总是返回object。</span><br><span class="line">alert(p1 instanceof Person);//<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>我们根据需要，可以给Person.prototype指定新的对象，来作为Person的原型对象。但是这个时候就会有个问题，新的对象的constructor属性则不再指向Person构造函数了。</p><p>看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接给Person的原型指定对象字面量。则这个对象的constructor属性不再指向Person函数</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"jshao"</span>,</span><br><span class="line">    age: <span class="string">"26"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line">alert(p1.name);<span class="comment">//jshao</span></span><br><span class="line"></span><br><span class="line">alert(p1 <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br><span class="line">alert(Person.prototype.constructor === Person);<span class="comment">//false</span></span><br><span class="line"><span class="comment">//如果constructor对你很重要，你应该在Person.prototype中添加一行这样的代码：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person.prototype = &#123;</span></span><br><span class="line"><span class="comment">    constructor: Person //让constructor重新指向Person函数</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="2-3-proto-属性（注意：左右各是两个下划线）"><a href="#2-3-proto-属性（注意：左右各是两个下划线）" class="headerlink" title="2.3 __proto__属性（注意：左右各是两个下划线）"></a>2.3 <code>__proto__</code>属性（注意：左右各是两个下划线）</h2><p>用构造方法创建一个新的对象之后，这个对象中默认会有一个不可访问的属性[[prototype]],这个属性就指向了构造方法的原型对象。<br>但是在个别浏览器中，也提供了对这个属性[[prototype]]的访问（chrome浏览器和火狐浏览器。ie浏览器不支持）。访问方式：<code>p1.__proto__</code></p><p>但是开发者尽量不要用这种方式去访问，因为操作不慎会改变这个对象的继承原型链。__</p><p>看如下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//直接给Person的原型指定对象字面量。则这个对象的constructor属性不再指向Person函数</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor: Person,</span><br><span class="line">    name: <span class="string">"jshao"</span>,</span><br><span class="line">    age: 26</span><br><span class="line">&#125;;</span><br><span class="line">var p1 = new Person();</span><br><span class="line">alert(p1.__proto__ === Person.prototype);//<span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="2-4-hasOwnProperty-方法"><a href="#2-4-hasOwnProperty-方法" class="headerlink" title="2.4 hasOwnProperty()方法"></a>2.4 hasOwnProperty()方法</h2><p>大家知道，我们去访问一个对象的属性的时候，这个属性既有可能来自对象本身，也有可能来自这个对象的[[prototype]]属性指向的原型。</p><p>那么如何判断这个对象的来源呢？</p><p>hasOwnProperty()方法，可以判断一个属性是否来自对象本身。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"jshao"</span>;</span><br><span class="line">var p1 = new Person();</span><br><span class="line">p1.sex = <span class="string">"男"</span>;</span><br><span class="line">//sex属性是直接在p1属性上添加，所以是<span class="literal">true</span></span><br><span class="line">alert(<span class="string">"sex属性是对象本身的："</span> + p1.hasOwnProperty(<span class="string">"sex"</span>));</span><br><span class="line">// name属性是在原型中添加的，所以是<span class="literal">false</span></span><br><span class="line">alert(<span class="string">"name属性是对象本身的："</span> + p1.hasOwnProperty(<span class="string">"name"</span>));</span><br><span class="line">// age 属性不存在，所以也是<span class="literal">false</span></span><br><span class="line">alert(<span class="string">"age属性是存在于对象本身："</span> + p1.hasOwnProperty(<span class="string">"age"</span>));</span><br></pre></td></tr></table></figure><p>所以，通过hasOwnProperty这个方法可以判断一个对象是否在对象本身添加的，但是不能判断是否存在于原型中，因为有可能这个属性不存在。<br>也就是说，在原型中的属性和不存在的属性都会返回false。<br>那如何判断一个属性是否存在于原型中呢？请接着往下看…</p><h2 id="2-5-in操作符"><a href="#2-5-in操作符" class="headerlink" title="2.5 in操作符"></a>2.5 in操作符</h2><p>in操作符用来判断一个属性是否存在于这个对象中。但是在查找这个属性的时候，先在对象本身中找，如果对象中找不到再去原型中找。换句话说，只要对象和原型中有一个地方存在这个属性，就返回true。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"jshao"</span>;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line">p1.sex = <span class="string">"男"</span>;</span><br><span class="line">alert(<span class="string">"sex"</span> <span class="keyword">in</span> p1);     <span class="comment">// 对象本身添加的，所以true</span></span><br><span class="line">alert(<span class="string">"name"</span> <span class="keyword">in</span> p1);    <span class="comment">//原型中存在，所以true</span></span><br><span class="line">alert(<span class="string">"age"</span> <span class="keyword">in</span> p1);     <span class="comment">//对象和原型中都不存在，所以false</span></span><br></pre></td></tr></table></figure><blockquote><p>回到前面的问题，如何判断一个属性是否存在于原型中：<br>如果一个属性存在，但是没有在对象本身中，则一定存在于原型中。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"jshao"</span>;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line">p1.sex = <span class="string">"男"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个函数去判断属性所在的位置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">propertyLocation</span>(<span class="params">obj,prop</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(prop <span class="keyword">in</span> obj))&#123;</span><br><span class="line">        alert(prop + <span class="string">"属性不存在"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(obj.hasOwnProperty(prop))&#123;</span><br><span class="line">        alert(prop + <span class="string">"属性存在于对象中"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        alert(prop + <span class="string">"属性存在于原型中"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">propertyLocation(p1, <span class="string">"age"</span>);<span class="comment">//属性不存在</span></span><br><span class="line">propertyLocation(p1, <span class="string">"name"</span>);<span class="comment">//属性存在于原型中</span></span><br><span class="line">propertyLocation(p1, <span class="string">"sex"</span>);<span class="comment">//属性存在于对象中</span></span><br></pre></td></tr></table></figure><h1 id="三、组合原型模型和构造函数模型创建对象"><a href="#三、组合原型模型和构造函数模型创建对象" class="headerlink" title="三、组合原型模型和构造函数模型创建对象"></a>三、组合原型模型和构造函数模型创建对象</h1><h2 id="3-1-原型模型创建对象的缺陷"><a href="#3-1-原型模型创建对象的缺陷" class="headerlink" title="3.1 原型模型创建对象的缺陷"></a>3.1 原型模型创建对象的缺陷</h2><p>原型中所有的属性都是共享的。也就是说，用同一个构造函数创建的对象去访问原型中的属性的时候，大家都是访问的同一个原型对象，如果原型对象对属性进行了修改，则会反映到所有创建的对象上。</p><p>但是在实际使用中，每个对象的属性一般是不同的。张三的姓名是张三，李四的姓名是李四。</p><p>==但是，这个共享特性对方法（属性值是函数的属性）又是非常合适的。==所有的对象共享方法是最佳状态。这种特性在c#和Java中是天生存在的。</p><h2 id="3-2-构造函数模型创建对象的缺陷"><a href="#3-2-构造函数模型创建对象的缺陷" class="headerlink" title="3.2 构造函数模型创建对象的缺陷"></a>3.2 构造函数模型创建对象的缺陷</h2><p>在构造函数中添加的属性和方法，每个对象都有自己独立的一份，大家不会共享。这个特性对属性比较合适，但是对方法又不太合适。因为对所有对象来说，他们的方法应该是一份就够了，没有必要每人一份，造成内存的浪费和性能的低下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"李四"</span>;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">this</span>.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"eat something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//每个对象都会有不同的方法</span></span><br><span class="line">alert(p1.eat === p2.eat);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><blockquote><p>可以使用下面的方法解决</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"李四"</span>;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">this</span>.eat = eat;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"eat something"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为eat属性都是赋值的同一个函数，所以是true</span></span><br><span class="line">alert(p1.eat === p2.eat); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><blockquote><p>但是上面的这种解决方法具有致命的缺陷：封装性太差。使用面向对象，目的之一就是封装代码，这个时候为了性能又要把代码抽出对象之外，这是反人类的设计。</p></blockquote><h2 id="3-3-使用组合模式解决上述两种缺陷"><a href="#3-3-使用组合模式解决上述两种缺陷" class="headerlink" title="3.3 使用组合模式解决上述两种缺陷"></a>3.3 使用组合模式解决上述两种缺陷</h2><p>原型模式适合封装方法，构造函数模式适合封装属性，综合两种模式的优点就有了组合模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//在构造方法内部封装属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在原型对象内封装方法</span></span><br><span class="line">Person.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name + <span class="string">"爱吃"</span> + food);</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.play = <span class="function"><span class="keyword">function</span> (<span class="params">playName</span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name + <span class="string">"爱玩"</span> + playName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">30</span>);</span><br><span class="line">p1.eat(<span class="string">"苹果"</span>);</span><br><span class="line">p2.eat(<span class="string">"香蕉"</span>);</span><br><span class="line">p1.play(<span class="string">"志玲"</span>);</span><br><span class="line">p2.play(<span class="string">"凤姐"</span>);</span><br></pre></td></tr></table></figure><h1 id="四、动态原型模式创建对象"><a href="#四、动态原型模式创建对象" class="headerlink" title="四、动态原型模式创建对象"></a>四、动态原型模式创建对象</h1><p>​前面讲到的组合模式，也并非完美无缺，有一点也是感觉不是很完美。把构造方法和原型分开写，总让人感觉不舒服，应该想办法把构造方法和原型封装在一起，所以就有了动态原型模式。</p><p>​动态原型模式把所有的属性和方法都封装在构造方法中，而仅仅在需要的时候才去在构造方法中初始化原型，又保持了同时使用构造函数和原型的优点。</p><blockquote><p>看下面的代码：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法内部封装属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//每个对象都添加自己的属性</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    判断this.eat这个属性是不是function，如果不是function则证明是第一次创建对象，则把这个function添加到原型中。如果是function，则代表原型中已经有这个方法，则不需要再添加。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.eat !=== <span class="string">'function'</span>)&#123;</span><br><span class="line">        Person.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.name + <span class="string">"eat something"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">"jshao"</span>,<span class="number">26</span>);</span><br><span class="line">    p1.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>组合模式和动态原型模式是JavaScript中使用比较多的两种创建对象的方式。建议以后使用动态原型模式。他解决了组合模式的封装不彻底的缺点。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- &lt;img src=&quot;/images/prototype&amp;__proto__.png&quot; style=&quot;width:100%;&quot; /&gt; --&gt;
&lt;!-- ![prototype&amp;__proto__](/images/prototype&amp;__proto__.png &quot;prot
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://jshao.org.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://jshao.org.cn/tags/javascript/"/>
    
      <category term="prototype" scheme="http://jshao.org.cn/tags/prototype/"/>
    
      <category term="__proto__" scheme="http://jshao.org.cn/tags/proto/"/>
    
      <category term="原型对象" scheme="http://jshao.org.cn/tags/%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
